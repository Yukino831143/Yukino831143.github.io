{"meta":{"title":"yukino","subtitle":null,"description":"一枚程序员的日常","author":"yukino","url":""},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-04-07T15:17:05.788Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-12T17:26:11.126Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[Yukino] 与&nbsp; Yukino&nbsp; （ Yukino ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-04-11T08:06:25.935Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-04-11T08:06:25.936Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-04-11T08:06:25.936Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura 主题balabala","keywords":"Lab实验室"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-04-11T08:06:25.935Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-04-11T08:06:25.937Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-04-11T08:06:25.937Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-04-07T15:17:05.790Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-04-07T15:17:05.790Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-07-12T17:26:11.127Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-04-07T15:17:05.791Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Daily Review","slug":"生活/Daily Review","date":"2020-10-20T18:20:00.000Z","updated":"2020-10-20T18:20:35.996Z","comments":true,"path":"2020/10/21/生活/Daily Review/","link":"","permalink":"/2020/10/21/生活/Daily Review/","excerpt":"","text":"2020-10-20 code study 23:50 - 1:50 下班时间 : 22:20 Java的基础知识，准备面试内容 Daily Review 坚持日更新，保持学习状态 解bug的速度远比不上报bug的速度。又报了一大波产线问题 修改了简历。 明天有音频基础知识授课。明天早上准备一波 2020-10-19 code study 22:30 - 1:45 下班时间 : 21:20 spring mvc 的 restful风格 和 拦截器 Daily Review 坚持日更新，保持学习状态 字节跳动 面试邀请，接下来的一周准备面试 中移物联网，还未修改简历，准备投一波 oppo的工作好忙，项目的一大波bug要解，一大波feature需要移植","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"Daily Review","slug":"Daily-Review","permalink":"/tags/Daily-Review/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"拦截器-Interceptor","slug":"技术/拦截器-Interceptor","date":"2020-10-19T17:50:00.000Z","updated":"2020-10-19T17:53:15.861Z","comments":true,"path":"2020/10/20/技术/拦截器-Interceptor/","link":"","permalink":"/2020/10/20/技术/拦截器-Interceptor/","excerpt":"","text":"拦截器(Interceptor)用于对URL请求进行前置/后置过滤 Interceptor与Filter用途相似，但实现方式不同 Interceptor底层就是基于Spring Aop面向切面编程实现 1.拦截器入门&lt;!--pom.xml--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!--applicationContext.xml--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; @RestController @RequestMapping(&quot;/restful&quot;) //@CrossOrigin(origins = {&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;}) //@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600) public class RestfulController { @GetMapping(&quot;/persons&quot;) public List&lt;Person&gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(&quot;lily&quot;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;smith&quot;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); System.out.println(&quot;RestfulController.findPersons() - return list&quot;); return list; } } public class MyInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL() + &quot;-准备执行&quot;); // response.getWriter().print(&quot;[]&quot;); return true;//返回false会直接拦截，不进行下一步传递 } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;); } } preHandle -前置执行处理 postHandle - 目标资源已经被Spring mvc 框架处理 afterCompletion - 响应文本已经产生 打印log http://localhost:8080/restful/persons-准备执行 RestfulController.findPersons() - return list http://localhost:8080/restful/persons-目标处理成功 http://localhost:8080/restful/persons-响应内容已产生 静态资源处理 因为按照上面的配置，当访问静态资源也会进行拦截，显然这是不合理的。 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 手动排除静态资源/**.ico 将静态资源放在统一目录/resource/ 指定访问的链接 /restful/** 2.多拦截器问题 &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/restful/**&quot;/&gt; &lt;mvc:mapping path=&quot;/webapi/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.ico&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; public class MyInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL() + &quot;-准备执行&quot;); // response.getWriter().print(&quot;[]&quot;);//拦截器输出到前端 return true;//返回false会直接拦截，不进行下一步传递 } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL() + &quot;-目标处理成功&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL() + &quot;-响应内容已产生&quot;); } } public class MyInterceptor1 implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(request.getRequestURL()+&quot;-准备执行-1&quot;); return true; } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(request.getRequestURL()+&quot;-目标处理成功-1&quot;); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(request.getRequestURL()+&quot;-响应内容已产生-1&quot;); } } 执行log http://localhost:8080/restful/persons-准备执行http://localhost:8080/restful/persons-准备执行-1RestfulController.findPersons() - return listhttp://localhost:8080/restful/persons-目标处理成功-1http://localhost:8080/restful/persons-目标处理成功http://localhost:8080/restful/persons-响应内容已产生-1http://localhost:8080/restful/persons-响应内容已产生 3.用户流量拦截器 引入logback &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 新建 resource/logback.xml&lt;!--logback.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration&gt; &lt;!--定义向控制台输出的追加器--&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--定义向log文件输出的追加器--&gt; &lt;appender name=&quot;accessHistoryLog&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;d:/logs/history.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出最低级别debug--&gt; &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;/root&gt; &lt;logger name=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot; level=&quot;INFO&quot; additivity=&quot;false&quot;&gt; &lt;!--level=&quot;INFO&quot; 默认输出等级 additivity=&quot;false&quot; 表示不输出到console，输出到文件--&gt; &lt;appender-ref ref=&quot;accessHistoryLog&quot;/&gt; &lt;/logger&gt; &lt;/configuration&gt; &lt;!--applicationContext.xml--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/resources/**&quot;/&gt; &lt;bean class=&quot;com.imooc.restful.interceptor.AccessHistoryInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;pattern&gt;[%thread] %d %level %logger{10} - %msg%n&lt;/pattern&gt; %pattern 线程名 %d 时间 %level 日志级别 %logger{10} 产生类日志，限定长度10 %msg log信息 %n 换行 RollingFileAppender 生成按天滚动的文件。每一天一个文件。 public class AccessHistoryInterceptor implements HandlerInterceptor { private Logger logger = LoggerFactory.getLogger(AccessHistoryInterceptor.class); public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { StringBuilder log = new StringBuilder(); log.append(request.getRemoteAddr()); log.append(&quot;|&quot;); log.append(request.getRequestURL()); log.append(&quot;|&quot;); log.append(request.getHeader(&quot;user-agent&quot;)); logger.info(log.toString()); return true; } } 4.Spring MVC处理流程","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Restful风格","slug":"技术/Restful","date":"2020-10-19T13:00:00.000Z","updated":"2020-10-19T17:51:28.500Z","comments":true,"path":"2020/10/19/技术/Restful/","link":"","permalink":"/2020/10/19/技术/Restful/","excerpt":"","text":"0. 基础介绍Restful开发规范 使用URL作为用户交互入口 明确的语义规范(GET|POST|PUT|DELETE) GET 查询 POST 新增 PUT 修改 DELETE 删除 Refstful命名要求 1.环境准备&lt;!--web.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;/web-app&gt; &lt;!--applicationContext.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.imooc.restful&quot;/&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;value&gt;application/json;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;/beans&gt; 2.Restful 注解 @RestController - 使用在类上，替代每个@ResponseBody，代表是restful数据而不是页面跳转 @PathVariable - 路径变量注解 @GetMapping @PostMapping -对应请求注解 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;RESTful实验室&lt;/title&gt; &lt;script src=&quot;jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $(&quot;#btnGet&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;get&quot; , dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function(){ $(&quot;#btnPost&quot;).click(function () { $.ajax({ url : &quot;/restful/request/100&quot;,//路径变量100 type : &quot;post&quot; , data : &quot;name=lily&amp;age=23&quot;,//数据 dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id); } }) }); }) $(function(){ $(&quot;#btnPut&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;put&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function(){ $(&quot;#btnDelete&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;delete&quot; , dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) $(function () { $(&quot;#btnPersons&quot;).click(function () { $.ajax({ url : &quot;/restful/persons&quot;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function(json){ console.info(json); for(var i = 0 ; i &lt; json.length;i++){ var p = json[i]; $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;) } } }) }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;btnGet&quot; value=&quot;发送Get请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnPost&quot; value=&quot;发送Post请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnPut&quot; value=&quot;发送Put请求&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;btnDelete&quot; value=&quot;发送Delete请求&quot;&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt; &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; @RestController //替代每个@ResponseBody，代表是restful数据而不是页面跳转 @RequestMapping(&quot;/restful&quot;) public class RestfulController { @GetMapping(&quot;/request&quot;) //@ResponseBody public String doGetRequest(){ return &quot;{\\&quot;message\\&quot;:\\&quot;返回查询结果\\&quot;}&quot;; } // POST /article/1 // POST /restful/request/100 // 获取路径变量 @PostMapping(&quot;/request/{rid}&quot;) //@ResponseBody public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据新建成功\\&quot;,\\&quot;id\\&quot;:&quot; + requestId + &quot;}&quot;; } @PutMapping(&quot;/request&quot;) //@ResponseBody public String doPutRequest(Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;}&quot;; } @DeleteMapping(&quot;/request&quot;) //@ResponseBody public String doDeleteRequest(){ return &quot;{\\&quot;message\\&quot;:\\&quot;数据删除成功\\&quot;}&quot;; } } 3.简单请求与非简单请求 简单请求是指标准结构的HTTP请求,对应GET/POST请求 非简单请求是复杂要求的HTTP请求,指PUT/DELETE、扩展标准请求 两者最大区别是非简单请求发送前需要发送预检请求 非简单请求 &lt;script&gt; $(function(){ $(&quot;#btnPost&quot;).click(function () { $.ajax({ url : &quot;/restful/request/100&quot;, type : &quot;post&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message+&quot;:&quot;+json.id); } }) }); }) $(function(){ $(&quot;#btnPut&quot;).click(function () { $.ajax({ url : &quot;/restful/request&quot;, type : &quot;put&quot; , data : &quot;name=lily&amp;age=23&quot;, dataType : &quot;json&quot; , success : function(json){ $(&quot;#message&quot;).text(json.message); } }) }); }) &lt;/script&gt; @PostMapping(&quot;/request/{rid}&quot;) //@ResponseBody public String doPostRequest(@PathVariable(&quot;rid&quot;) Integer requestId, Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据新建成功\\&quot;,\\&quot;id\\&quot;:&quot; + requestId + &quot;}&quot;; } @PutMapping(&quot;/request&quot;) //@ResponseBody public String doPutRequest(Person person){ System.out.println(person.getName() + &quot;:&quot; + person.getAge()); return &quot;{\\&quot;message\\&quot;:\\&quot;数据更新成功\\&quot;}&quot;; } 由于Post请求是简单请求,可以得到执行结果 lily:23 但Put请求是非简单请求，执行结果 null:null 为了使非简单请求，能够获取到数据。需要在web.xml增加配置 &lt;!--web.xml--&gt; &lt;filter&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.FormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;formContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 4.JSON序列化public class Person { private String name; private Integer age; @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot; , timezone = &quot;GMT+8&quot;) private Date birthday; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } } @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss” , timezone = “GMT+8”) 对日期进行格式化，JackSon的默认时区为格林尼治时间(GMT),北京时间为东八区。需要进行转换时区。 @GetMapping(&quot;/person&quot;) public Person findByPersonId(Integer id){ Person p = new Person(); if(id==1){ p.setName(&quot;lily&quot;); p.setAge(23); }else if(id==2){ p.setName(&quot;smith&quot;); p.setAge(22); } return p; } @GetMapping(&quot;/persons&quot;) public List&lt;Person&gt; findPersons(){ List list = new ArrayList(); Person p1 = new Person(); p1.setName(&quot;lily&quot;); p1.setAge(23); p1.setBirthday(new Date()); Person p2 = new Person(); p2.setName(&quot;smith&quot;); p2.setAge(22); p2.setBirthday(new Date()); list.add(p1); list.add(p2); return list; } &lt;script&gt; $(function () { $(&quot;#btnPersons&quot;).click(function () { $.ajax({ url : &quot;/restful/persons&quot;, type : &quot;get&quot;, dataType : &quot;json&quot;, success : function(json){ console.info(json); for(var i = 0 ; i &lt; json.length;i++){ var p = json[i]; $(&quot;#divPersons&quot;).append(&quot;&lt;h2&gt;&quot; + p.name + &quot;-&quot; + p.age + &quot;-&quot; + p.birthday+ &quot;&lt;/h2&gt;&quot;) } } }) }) }) &lt;/script&gt; &lt;body&gt; &lt;h1 id=&quot;message&quot;&gt;&lt;/h1&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; id=&quot;btnPersons&quot; value=&quot;查询所有人员&quot;&gt; &lt;div id=&quot;divPersons&quot;&gt;&lt;/div&gt; &lt;/body&gt; 5.跨域请求5.1 跨域基础知识浏览器同源策略 同源策略阻止一个域加载的脚本去获取另一个域上的资源 只要协议、域名、端口有一个不同，都被当作是不同的域 浏览器Console看到 Access-Control-Allow-Origin就代表跨域了 同源策略示例 HTML中允许跨域的标签 &lt;img&gt; - 显示远程图片 &lt;script&gt; - 加载远程JS &lt;link&gt; - 加载远程CSS 个人经历 年少时玩爬虫的时候，目标是直接爬取B站的数据，直接显示在自己的界面。B站有一个服务器，是restful风格提供数据。通过前端直接去B站服务器的Json数据。结果发现一直是无法成功获取。这个问题就是同源策略。后面还是只有通过后端语音拿到数据再传到前端瞬间实现。 CORS跨域资源访问 CORS是一种机制,使用额外的HTTP头通知浏览器可以访问其他域，其实是浏览器发现是跨域，所以进行拦截了。 URL响应头包含 Access-Control-*指明请求允许跨域，浏览器发现带有这个response头，就放行了。 跨域访问，在Request Headers中，有字段Sec-Fetch-Mode: cors5.2 Spring MVC解决跨域访问 @CrossOrigin－ Controller跨域注解 mvc:cors - Spring MVC全局跨域配置 @CrossOrigin`Java@RestController//替代每个@ResponseBody，代表是restful数据而不是数据跳转@RequestMapping(“/restful”)//@CrossOrigin(origins = {“http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;})//@CrossOrigin(origins = “*”,maxAge = 3600)public class RestfulController { } 在Controller类上添加注解 `@CrossOrigin(origins = {&quot;http://localhost:8080&quot;,&quot;http://www.imooc.com&quot;})` `@CrossOrigin(origins = &quot;*&quot;,maxAge = 3600)` maxAge的意思是浏览器的非简单请求在实际请求之前，会先发送预检请求。 maxAge 即保存预简请求的时间，在这期间。非简单请求就不用发送预检请求了，缓解服务器的压力。 2. &lt;mvc:cors&gt; ```Xml &lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/restful/**&quot; allowed-origins=&quot;http://localhost:8080,http://www.imooc.com&quot; max-age=&quot;3600&quot;/&gt; &lt;/mvc:cors&gt; 其中 path=&quot;/restful/** 表示访问的目标域名为restful/ 下的所有域名 总结 mvc:cors 的优势方便配置全局跨域访问。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring MVC","slug":"技术/Spring MVC","date":"2020-10-18T13:00:00.000Z","updated":"2020-10-19T17:49:49.689Z","comments":true,"path":"2020/10/18/技术/Spring MVC/","link":"","permalink":"/2020/10/18/技术/Spring MVC/","excerpt":"","text":"1.环境配置&lt;!--web.xml--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- DispatcherServlet是Spring MVC最核心的对象 DispatcherServlet用于拦截Http请求, 并根据请求的URL调用与之对应的Controller方法,来完成Http请求的处理 --&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--applicationContext.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 在Web应用启动时自动创建Spring IOC容器, 并初始化DispatcherServlet --&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--&quot;/&quot; 代表拦截所有请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mv=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- context:component-scan 标签作用 在Spring IOC初始化过程中,自动创建并管理com.imooc.springmvc及子包中 拥有以下注解的对象. @Repository @Service @Controller @Component --&gt; &lt;context:component-scan base-package=&quot;com.imooc.springmvc&quot;&gt;&lt;/context:component-scan&gt; &lt;!--1.启用Spring MVC的注解开发模式--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 将图片/JS/CSS等静态资源排除在外,可提高执行效率 --&gt; &lt;mvc:default-servlet-handler/&gt; 2.URL Mapping注解作用URL Mapping将URL与Controller方法进行绑定 RequestMapping - 通用绑定 GetMaping - 绑定Get请求 PostMapping - 绑定Post请求 前端Post 请求 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/um/p1&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;username&quot;&gt; &lt;br&gt; &lt;input name=&quot;password&quot;&gt; &lt;br&gt; &lt;input name=&quot;createTime&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; @Controller @RequestMapping(&quot;/um&quot;) //为所有类的映射都添加一个前缀 public class URLMappingController { @GetMapping(&quot;/g&quot;) @ResponseBody //manager_name参数映射到String managerName //Date createTime 是使用MyDateConverter类在applicationContext.xml配置进行日期转换的 public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName,Date createTime){ System.out.println(&quot;managerName:&quot; + managerName); System.out.println(createTime); return &quot;This is get method&quot;; } @PostMapping(&quot;/p&quot;) @ResponseBody public String postMapping(String username, Long password) { System.out.println(username + &quot;:&quot; + password); return &quot;This is post method&quot;; } @PostMapping(&quot;/p1&quot;) @ResponseBody //1.可以用对象User进行接收Post参数，其中createTime字段，在User类中，需要使用DateTimeFormat //2.单独接收createTime 时，也可以形式参数中@DateTimeFormat，指明格式 //3.String username也可以接收到数据 public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } } public class User { private String username; private Long password; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date createTime; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getPassword() { return password; } public void setPassword(Long password) { this.password = password; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } 3.接收表单复杂数据&lt;div class=&quot;container&quot;&gt; &lt;h2&gt;学员调查问卷&lt;/h2&gt; &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt; &lt;h3&gt;您的姓名&lt;/h3&gt; &lt;input name=&quot;name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt; &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt; &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt; &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt; &lt;/select&gt; &lt;div&gt; &lt;h3&gt;您的学习目的：&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他 &lt;/div&gt; &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; @Controller public class FormContoller { @PostMapping(&quot;/apply&quot;) @ResponseBody //1.@RequestParam 指定接收到的参数为n,默认值为&quot;ANON&quot;,可避免无法匹配到参数时，出现的异常 //2.复选框使用数组Integer[] purpose，接收 public String apply(@RequestParam(value = &quot;n&quot;, defaultValue = &quot;ANON&quot;) String name, String course, Integer[] purpose) { System.out.println(&quot;name:&quot; + name); System.out.println(&quot;course:&quot; + course); for(Integer p : purpose){ System.out.println(&quot;purpose:&quot; + p); } return &quot;SUCCES&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //@RequestParam表示将接收到的数据转换成List，一定要加 public String apply(String name, String course, @RequestParam List&lt;Integer&gt; purpose){ System.out.println(&quot;name:&quot; + name); System.out.println(&quot;course:&quot; + course); for(Integer p : purpose){ System.out.println(&quot;purpose:&quot; + p); } return &quot;SUCCES&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //以对象方式接收参数 public String apply(Form form) { System.out.println(form.getName()); System.out.println(form.getCourse()); for(Integer p : form.getPurpose()) { System.out.println(p); } return &quot;SUCCESS&quot;; } // @PostMapping(&quot;/apply&quot;) @ResponseBody //注意Map类型最好不要用因为Map类型对于传过来的purpose参数，对于复杂类型，如复选框，只会取第一个值。漏掉数据 public String apply(@RequestParam Map map){ System.out.println(map); return &quot;SUCCESS&quot;; } } public class Form { private String name; private String course; private List&lt;Integer&gt; purpose; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCourse() { return course; } public void setCourse(String course) { this.course = course; } public List&lt;Integer&gt; getPurpose() { return purpose; } public void setPurpose(List&lt;Integer&gt; purpose) { this.purpose = purpose; } } 4.关联对象赋值 &lt;h2&gt;学员调查问卷&lt;/h2&gt; &lt;form action=&quot;./apply&quot; method=&quot;post&quot;&gt; &lt;h3&gt;您的姓名&lt;/h3&gt; &lt;input name=&quot;name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;您正在学习的技术方向&lt;/h3&gt; &lt;select name=&quot;course&quot; style=&quot;width: 150px&quot;&gt; &lt;option value=&quot;java&quot;&gt;Java&lt;/option&gt; &lt;option value=&quot;h5&quot;&gt;HTML5&lt;/option&gt; &lt;option value=&quot;python&quot;&gt;Python&lt;/option&gt; &lt;option value=&quot;php&quot;&gt;PHP&lt;/option&gt; &lt;/select&gt; &lt;div&gt; &lt;h3&gt;您的学习目的：&lt;/h3&gt; &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;1&quot;&gt;就业找工作 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;2&quot;&gt;工作要求 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;3&quot;&gt;兴趣爱好 &lt;input type=&quot;checkbox&quot; name=&quot;purpose&quot; value=&quot;4&quot;&gt;其他 &lt;/div&gt; &lt;h3&gt;收货人&lt;/h3&gt; &lt;input name=&quot;delivery.name&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;联系电话&lt;/h3&gt; &lt;input name=&quot;delivery.mobile&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;h3&gt;收货地址&lt;/h3&gt; &lt;input name=&quot;delivery.address&quot; class=&quot;text&quot; style=&quot;width: 150px&quot;&gt; &lt;div style=&quot;text-align: center;padding-top:10px&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; style=&quot;width:100px&quot;&gt; &lt;/div&gt; &lt;/form&gt; delivery.name delivery.mobile delivery.address public class Delivery { private String name; private String address; private String mobile; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public String getMobile() { return mobile; } public void setMobile(String mobile) { this.mobile = mobile; } } public class Form { private String name; private String course; private List&lt;Integer&gt; purpose; private Delivery delivery = new Delivery();//关联对象 public Delivery getDelivery() { return delivery; } public void setDelivery(Delivery delivery) { this.delivery = delivery; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCourse() { return course; } public void setCourse(String course) { this.course = course; } public List&lt;Integer&gt; getPurpose() { return purpose; } public void setPurpose(List&lt;Integer&gt; purpose) { this.purpose = purpose; } } @PostMapping(&quot;/apply&quot;) @ResponseBody //注意Map类型最好不要用因为Map类型对于传过来的purpose参数，只会取第一个 public String applyDelivery(Form form){ System.out.println(form.getDelivery().getName()); return &quot;SUCCESS&quot;; } 5.日期转换 @DateTimeFormat指定格式，将String 类型转换称日期类型 @PostMapping(&quot;/p1&quot;) @ResponseBody //1.可以用对象User进行接收Post参数，其中createTime字段，在User类中，需要使用DateTimeFormat //2.单独接收createTime 时，也可以形式参数中@DateTimeFormat，指明格式 public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } 对象成员 注解 public class User { private String username; private Long password; //@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date createTime; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public Long getPassword() { return password; } public void setPassword(Long password) { this.password = password; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } } public String postMapping(User user, String username, @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date createTime) { System.out.println(user.getUsername() + &quot;:&quot; + user.getPassword()); System.out.println(&quot;date:&quot; + user.getCreateTime()); return &quot;&lt;h1&gt;这是Post响应&lt;/h1&gt;&quot;; } User 对象的成员变量自动转换 自定义日期转换类 //日期转换 public class MyDateConverter implements Converter&lt;String, Date&gt; { public Date convert(String s) { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); try { Date d = sdf.parse(s); return d; } catch (ParseException e) { return null; } } } &lt;!--applicationContext.xml--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;!--指定日期转换类--&gt; &lt;bean class=&quot;com.imooc.springmvc.converter.MyDateConverter&quot;/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; @GetMapping(&quot;/g&quot;) @ResponseBody //manager_name参数映射到String managerName //Date createTime 是使用MyDateConverter类在applicationContext.xml配置进行日期转换的 public String getMapping(@RequestParam(&quot;manager_name&quot;) String managerName,Date createTime){ System.out.println(&quot;managerName:&quot; + managerName); System.out.println(createTime); return &quot;This is get method&quot;; } Date createTime 没有加注解，也可以转换 注意：注解与自定义日期转换类同时存在时，以日期转换类优先 6.中文乱码问题 Get乱码问题 - server.xml增加URIEncoding属性 Post请求乱码 - Web.xml 配置 CharacterEncodingFilter Response响应乱码 - spring配置StringHttpMessageConverter 6.1 getPath:”Tomcat v8.5 Server at localhost-config\\server.xml” &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 在tomcat8 以下的版本需要增加URIEncoding，以上版本默认是UTF-8 6.2 post通过过滤器来实现post编码 &lt;!--web.xml--&gt; &lt;filter&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 6.3 Response&lt;!--applicationContext.xml--&gt; &lt;!--3.message-converters 配置Response响应字符集--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;!-- response.setContentType(&quot;text/html;charset=utf-8&quot;) --&gt; &lt;value&gt;text/plain;charset=utf-8&lt;/value&gt; &lt;value&gt;text/html;charset=utf-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 7.响应输出7.1 ModelAndView","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Spring MVC","slug":"Spring-MVC","permalink":"/tags/Spring-MVC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Spring 事务管理","slug":"技术/Spring 事务管理","date":"2020-10-18T07:00:00.000Z","updated":"2020-10-18T07:46:40.308Z","comments":true,"path":"2020/10/18/技术/Spring 事务管理/","link":"","permalink":"/2020/10/18/技术/Spring 事务管理/","excerpt":"","text":"什么是事务？ 事务一般指的是数据库事务(Database Transaction),是指一个程序执行单元，要么完全执行，要么完全不执行 事务并发问题 脏读 解决方法：只能读取永久数据，不能读取内存中的数据 不可重复读 解决方法：锁行 幻读 解决方法：锁表 Mysql事务隔离级别 JDBC事务隔离级别 事务传播行为 0. 公共代码&lt;!--spring-dao.xml--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/os?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;foreverlove&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--在 XML 配置文件中启动 Spring 的自动扫描功能 我们就不再需要在 XML 中显式使用 &lt;bean/&gt; 进行Bean 的配置。 Spring 在容器初始化时将自动扫描 com.imooc.os.dao 指定的包及其子包下的所有 class文件， 所有标注了 @Repository 的类都将被注册为 Spring Bean。 --&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.dao&quot;/&gt; &lt;/beans&gt; @Repository public class OrderDaoImpl implements OrderDao { @Autowired private JdbcTemplate jdbcTemplate; public void insert(Order order) { String sql = &quot;insert into orders values(?,?,?,?,?,?,?,?,?,?,?)&quot;; jdbcTemplate.update(sql,order.getId(),order.getProductsId(),order.getNumber(),order.getPrice(),order.getCreateTime(),order.getSendTime(),order.getConfirmTime(),order.getConsignee(),order.getConsigneePhone(),order.getConsigneeAddress(),order.getStatus()); } public void update(Order order) { String sql = &quot;update orders set create_time=?,send_time=?,confirm_time=?,consignee=?,consignee_phone=?,consignee_address=?,status=? where id=?&quot;; jdbcTemplate.update(sql,order.getProductsId(),order.getNumber(),order.getPrice(),order.getCreateTime(),order.getSendTime(),order.getConfirmTime(),order.getConsignee(),order.getConsigneePhone(),order.getConsigneeAddress(),order.getStatus(),order.getId()); } public void delete(String id) { String sql = &quot;delete from orders where id=?&quot;; jdbcTemplate.update(sql,id); } public Order select(String id) { String sql = &quot;select form orders where id=?&quot;; return jdbcTemplate.queryForObject(sql,new OrderRowMapper(),id); } public List&lt;Order&gt; select() { String sql = &quot;select form orders&quot;; return jdbcTemplate.query(sql,new OrderRowMapper()); } private class OrderRowMapper implements RowMapper&lt;Order&gt;{ public Order mapRow(ResultSet resultSet, int i) throws SQLException { Order order=new Order(); order.setId(resultSet.getString(&quot;id&quot;)); order.setProductsId(resultSet.getString(&quot;product_id&quot;)); order.setNumber(resultSet.getInt(&quot;number&quot;)); order.setPrice(resultSet.getDouble(&quot;price&quot;)); order.setCreateTime(resultSet.getTimestamp(&quot;create_time&quot;)); order.setSendTime(resultSet.getTimestamp(&quot;send_time&quot;)); order.setConfirmTime(resultSet.getTimestamp(&quot;confirm_time&quot;)); order.setConsignee(resultSet.getString(&quot;consignee&quot;)); order.setConsigneePhone(resultSet.getString(&quot;consignee_phone&quot;)); order.setConsigneeAddress(resultSet.getString(&quot;consignee_address&quot;)); order.setStatus(resultSet.getString(&quot;status&quot;)); return order; } } } @Repository public class ProductDaoImpl implements ProductDao { @Autowired private JdbcTemplate jdbcTemplate; public void insert(Product product) { String sql = &quot;insert into products values(?,?,?,?,?)&quot;; jdbcTemplate.update(sql,product.getId(),product.getTitle(),product.getPrice(),product.getStock(),product.getStatus()); } public void update(Product product) { String sql = &quot;update products set title=?,price=?,stock=?,status=? where id=?&quot;; jdbcTemplate.update(sql,product.getTitle(),product.getPrice(),product.getStock(),product.getStatus(),product.getId()); } public void delete(String id) { String sql = &quot;delete form products where id=?&quot;; jdbcTemplate.update(sql,id); } public Product select(String id) { String sql = &quot;select * from products where id=?&quot;; return jdbcTemplate.queryForObject(sql,new ProductRowMapper(),id); } public List&lt;Product&gt; select() { String sql = &quot;select * from products&quot;; return jdbcTemplate.query(sql,new ProductRowMapper()); } private class ProductRowMapper implements RowMapper&lt;Product&gt;{ public Product mapRow(ResultSet resultSet, int i) throws SQLException { Product product = new Product(); product.setId(resultSet.getString(&quot;id&quot;)); product.setTitle(resultSet.getString(&quot;title&quot;)); product.setPrice(resultSet.getDouble(&quot;price&quot;)); product.setStock(resultSet.getInt(&quot;stock&quot;)); product.setStatus(resultSet.getString(&quot;status&quot;)); return product; } } } 1.Spring编程式事物处理1.1 方式1 基于底层API的编程式事物处理 PlatformTransactionManager TransactionDefinition TransactionStatus &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl1&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionDefinition&quot; class=&quot;org.springframework.transaction.support.DefaultTransactionDefinition&quot;&gt; &lt;property name=&quot;propagationBehaviorName&quot; value=&quot;PROPAGATION_REQUIRED&quot;/&gt; &lt;!--PROPAGATION_REQUIRED 表示 事务传播行为--支持当前事务，如果没有当前事务，就新建一个事务--&gt; &lt;!--也可配置隔离级别等其他属性，不配置即使用默认--&gt; &lt;/bean&gt; &lt;/beans&gt; package com.imooc.os.service; import com.imooc.os.entity.Order; public interface OrderService { void addOrder(Order order); } /*1.基于底层API的方式 PlatformTransactionManager TransactionDefinition*/ @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; @Autowired private PlatformTransactionManager transactionManager; @Autowired private TransactionDefinition transactionDefinition; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); //开启事务 TransactionProxyFactoryBean transactionProxyFactoryBean; TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition); try { orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); //结束事务 transactionManager.commit(transactionStatus); }catch (Exception e){ e.printStackTrace(); //出问题，将未提交的sql回滚 transactionManager.rollback(transactionStatus); } } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service1.xml&quot;) //1.基于底层api的编程式事务处理方式 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 1.2 基于TransactionTemplate的编程式事务管理 TransactionTemplate &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl2&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; //2.基于TransactionTemplate的编程式事务管理 @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; //2.TransactionTemplate 用于简化底层API @Autowired private TransactionTemplate transactionTemplate; public void addOrder(final Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); transactionTemplate.execute(new TransactionCallback() { public Object doInTransaction(TransactionStatus transactionStatus) { try { orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); //不需要提交，TransactionTemplate会帮你提交 }catch (Exception e){ e.printStackTrace(); transactionStatus.setRollbackOnly();//回滚 } return null; } }); } } public interface OrderService { void addOrder(Order order); } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service2.xml&quot;) //2.基于TransactionTemplate的编程式事务管理 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.Spring声明式事务处理简介 Spring的声明式事务处理是建立在AOP的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或加一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 建议在开发中使用声明式事务，使得业务代码纯粹干净，方便后期代码维护 分类 基于TransactionInterceptor的声明式事务处理。 基于TransactionProxyFactoryBean的声明式事务处理。 基于 命名空间的声明式事物管理。 基于 @Transactional的声明式事务管理。 2.1 基于TransactionInterceptor的声明式事务处理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--1.基于TransactionInterceptor的声明式事务处理--&gt; &lt;bean id=&quot;orderServiceTarget&quot; class=&quot;com.imooc.os.service.impl.OrderServiceImpl&quot;/&gt; &lt;bean id=&quot;transactionInterceptor&quot; class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt; &lt;!--配置事务管理器--&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;!--配置拦截器--&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;!--key是方法，配置事务传播行为，属性--&gt; &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;find*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;search*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--用拦截器增强目标类，建立关联--&gt; &lt;bean id=&quot;orderService&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;property name=&quot;target&quot; ref=&quot;orderServiceTarget&quot;/&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;idref bean=&quot;transactionInterceptor&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } 对于addOrder，由于拦截器增强，出错时，这个函数的操作自动回滚。 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service3.xml&quot;) //3.基于TransactionInterceptor的声明式事务处理 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.2 基于TransactionProxyFactoryBean的声明式事务处理&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--2.基于TransactionProxyFactoryBean的声明式事务处理，其实就是简化上面的那种拦截器--&gt; &lt;bean id=&quot;orderServiceTarget&quot; class=&quot;com.imooc.os.service.impl.OrderServiceImpl&quot;/&gt; &lt;bean id=&quot;orderService&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt; &lt;property name=&quot;transactionAttributes&quot;&gt; &lt;props&gt; &lt;prop key=&quot;get*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;find*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;search*&quot;&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt; &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;target&quot; ref=&quot;orderServiceTarget&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service4.xml&quot;) //4.基于TransactionProxyFactoryBean的声明式事务处理，其实就是简化上面的那种拦截器 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.3 (最推荐)基于 命名空间的声明式事物管理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--3.基于&lt;tx&gt;命名空间的声明式事务处理，这种是实际开发常用的--&gt; &lt;!--增加通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--增强的地方,在哪个方法增强--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.imooc.os.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service5.xml&quot;) //5.基于&lt;tx&gt;命名空间的声明式事务处理，这种是实际开发常用的 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } } 2.4 基于 @Transactional的声明式事务管理。&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;context:component-scan base-package=&quot;com.imooc.os.service.impl6&quot;/&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--4.基于@Transactional的声明式事务管理--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt; @Service public class OrderServiceImpl implements OrderService { @Autowired private OrderDao orderDao; @Autowired private ProductDao productDao; //4.基于@Transactional的声明式事务管理 @Transactional(propagation = Propagation.REQUIRED) public void addOrder(Order order) { order.setCreateTime(new Date()); order.setStatus(&quot;待付款&quot;); orderDao.insert(order); Product product = productDao.select(order.getProductsId()); product.setStock(product.getStock() - order.getNumber()); productDao.update(product); } } @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(&quot;classpath:spring-service6.xml&quot;) //6.基于@Transactional的声明式事务管理,这种是实际开发常用的 public class OrderTest { @Autowired private OrderService orderService; @Test public void testAddOrder(){ Order order = new Order(&quot;100013&quot;,&quot;100002&quot;,2,1799,&quot;&quot;,&quot;&quot;,&quot;&quot;); orderService.addOrder(order); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"JDBC Template","slug":"技术/JDBC Template","date":"2020-10-17T06:00:00.000Z","updated":"2020-10-18T07:37:07.724Z","comments":true,"path":"2020/10/17/技术/JDBC Template/","link":"","permalink":"/2020/10/17/技术/JDBC Template/","excerpt":"","text":"1.JDBC Template简介Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。 2.codespring.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/selection_course?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;foreverlove&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--在 XML 配置文件中启动 Spring 的自动扫描功能 我们就不再需要在 XML 中显式使用 &lt;bean/&gt; 进行Bean 的配置。 Spring 在容器初始化时将自动扫描 com.imooc.sc 指定的包及其子包下的所有 class文件， 所有标注了 @Repository 的类都将被注册为 Spring Bean。 --&gt; &lt;context:component-scan base-package=&quot;com.imooc.sc&quot;/&gt; &lt;/beans&gt; 基本操作手法 public class Test { private JdbcTemplate jdbcTemplate; { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); jdbcTemplate = (JdbcTemplate)context.getBean(&quot;jdbcTemplate&quot;); } //create @org.junit.Test public void testExecute(){ jdbcTemplate.execute(&quot;create table user1(id int,name varchar(20))&quot;); } //insert @org.junit.Test public void testUpdate(){ String sql = &quot;insert into student(name,sex) values(?,?)&quot;; jdbcTemplate.update(sql,new Object[]{&quot;张飞&quot;,&quot;男&quot;}); } //update @org.junit.Test public void testUpdate2(){ String sql = &quot;update student set sex=? where id=?&quot;; jdbcTemplate.update(sql,&quot;女&quot;,1); } //批量更新 @org.junit.Test public void testBatchUpdate(){ String[] sqls={ &quot;insert into student(name,sex) values(&#39;关羽&#39;,&#39;女&#39;)&quot;, &quot;insert into student(name,sex) values(&#39;刘备&#39;,&#39;男&#39;)&quot;, &quot;update student set sex=&#39;女&#39; where id=1&quot; }; jdbcTemplate.batchUpdate(sqls); } //批量更新 public void testBatchUpdate2(){ String sql = &quot;insert into selection(student,course) values(?,?)&quot;; List&lt;Object[]&gt; list = new ArrayList&lt;Object[]&gt;(); list.add(new Object[]{1005,1001}); list.add(new Object[]{1005,1003}); jdbcTemplate.batchUpdate(sql,list); } //查询 @org.junit.Test public void testQuerySimple1(){ String sql = &quot;select count(*) from student&quot;; int count = jdbcTemplate.queryForObject(sql,Integer.class); System.out.println(count); } @org.junit.Test public void testQuerySimple2(){ String sql = &quot;select name from student where sex=?&quot;; List&lt;String&gt; names = jdbcTemplate.queryForList(sql,String.class,&quot;女&quot;); System.out.println(names); } //查询结果为map @org.junit.Test public void testQueryMap1(){ String sql = &quot;select * from student where id = ?&quot;; Map&lt;String,Object&gt; stu = jdbcTemplate.queryForMap(sql,1); System.out.println(stu);//{id=1, name=张飞, sex=女, born=null} } @org.junit.Test public void testQueryMap2(){ String sql = &quot;select * from student&quot;; List&lt;Map&lt;String,Object&gt;&gt; stus = jdbcTemplate.queryForList(sql); System.out.println(stus); //[{id=1, name=张飞, sex=女, born=null}, {id=2, name=关羽, sex=女, born=null}] } //查询结果返回对象 public void testQueryEntity1(){ String sql = &quot;select * from student where id = ?&quot;; Student stu = jdbcTemplate.queryForObject(sql, new StudentRowMapper(), 1004); System.out.println(stu); } @org.junit.Test public void testQueryEntity2(){ String sql = &quot;select * from student&quot;; List&lt;Student&gt; stus = jdbcTemplate.query(sql,new StudentRowMapper()); System.out.println(stus); } private class StudentRowMapper implements RowMapper&lt;Student&gt;{ public Student mapRow(ResultSet resultSet, int i) throws SQLException { Student stu = new Student(); stu.setId(resultSet.getInt(&quot;id&quot;)); stu.setName(resultSet.getString(&quot;name&quot;)); stu.setSex(resultSet.getString(&quot;sex&quot;)); stu.setBorn(resultSet.getDate(&quot;born&quot;)); return stu; } } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"spring","slug":"spring","permalink":"/tags/spring/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"桥接模式","slug":"技术/桥接模式","date":"2020-10-13T16:30:00.000Z","updated":"2020-10-13T16:27:24.935Z","comments":true,"path":"2020/10/14/技术/桥接模式/","link":"","permalink":"/2020/10/14/技术/桥接模式/","excerpt":"","text":"基本介绍 桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。 是一种结构型设计模式 Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的 功能扩展 UML CODE public interface Brand { void open(); void close(); } public class Vivo implements Brand { @Override public void open() { System.out.println(&quot;VIVO手机开机&quot;); } @Override public void close() { System.out.println(&quot;VIVO手机关机&quot;); } } public class Xiaomi implements Brand { @Override public void open() { System.out.println(&quot;Xiaomi手机开机&quot;); } @Override public void close() { System.out.println(&quot;Xiaomi手机关机&quot;); } } public abstract class Phone { private Brand brand; public Phone(Brand brand) { this.brand = brand; } protected void open() { brand.open(); } protected void close() { brand.close(); } } public class FoldedPhone extends Phone { public FoldedPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(&quot;折叠样式手机&quot;); } public void close() { super.close(); System.out.println(&quot;折叠样式手机&quot;); } } public class UpRightPhone extends Phone { //构造器 public UpRightPhone(Brand brand) { super(brand); } public void open() { super.open(); System.out.println(&quot; 直立样式手机 &quot;); } public void close() { super.close(); System.out.println(&quot; 直立样式手机 &quot;); } } public class Client { public static void main(String[] args) { //获取折叠式手机 (样式 + 品牌 ) Phone phone1 = new FoldedPhone(new Xiaomi()); phone1.open(); phone1.close(); System.out.println(&quot;=======================&quot;); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.close(); System.out.println(&quot;==============&quot;); UpRightPhone phone3 = new UpRightPhone(new Xiaomi()); phone3.open(); phone3.close(); System.out.println(&quot;==============&quot;); UpRightPhone phone4 = new UpRightPhone(new Vivo()); phone4.open(); phone4.close(); } } 优缺点 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于 系统进行分层设计，从而产生更好的结构化系统。 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程 桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。 桥接模式其它应用场景对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"适配器模式","slug":"技术/适配器模式","date":"2020-10-08T15:30:00.000Z","updated":"2020-10-08T15:31:39.776Z","comments":true,"path":"2020/10/08/技术/适配器模式/","link":"","permalink":"/2020/10/08/技术/适配器模式/","excerpt":"","text":"基本介绍 适配器模式(AdapterPattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本 因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)尚硅谷 Java 设计模式第 9 章 适配器设计模式 9.1 现实生活中的适配器例子 适配器模式属于结构型模式 主要分为三类:类适配器模式、对象适配器模式、接口适配器模式 1.类适配器模式 应用实例说明 以生活中充电器的例子来讲解适配器，充电器本身相当于 Adapter，220V 交流电相当于 src (即被适配者)，我们 的目 dst(即 目标)是 5V 直流电 UML CODE public class Voltage220V { public int output220V() { int src = 220; System.out.println(&quot;电压=&quot; + src + &quot;V&quot;); return src; } } public interface IVoltage5V { public int output5V(); } public class VoltageAdapter extends Voltage220V implements IVoltage5V{ @Override public int output5V() { int srcV = output220V(); int dstV = srcV / 44; return dstV; } } public class Client { public static void main(String[] args) { System.out.println(&quot;类适配器模式&quot;); VoltageAdapter voltageAdapter = new VoltageAdapter(); System.out.println(&quot;转换后电压&quot; + voltageAdapter.output5V()); } } 优缺点 Java 是单继承机制，所以类适配器需要继承 src 类这一点算是一个缺点, 因为这要求 dst 必须是接口，有一定局 限性; src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。 2.对象适配器模式介绍 根据“合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系。 UML CODE public interface IVoltage5V { public int output5V(); } public class Voltage220V { public int output220V() { int src = 220; System.out.println(&quot;电压=&quot; + src + &quot;V&quot;); return src; } } public class VoltageAdapter implements IVoltage5V { private Voltage220V voltage220V; public VoltageAdapter(Voltage220V voltage220V) { this.voltage220V = voltage220V; } @Override public int output5V() { int srcV = voltage220V.output220V(); int dstV = srcV / 44; return dstV; } } public class Client { public static void main(String[] args) { System.out.println(&quot;类适配器模式&quot;); VoltageAdapter voltageAdapter = new VoltageAdapter(new Voltage220V()); System.out.println(&quot;转换后电压&quot; + voltageAdapter.output5V() + &quot;V&quot;); } } 优缺点 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。 根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 src 的局限性问题，也不再要求 dst 必须是接口。 3.接口适配器模式介绍 一些书籍称为:适配器模式(DefaultAdapterPattern)或缺省适配器模式。 核心思路:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求 适用于一个接口不想使用其所有的方法的情况。 UML CODE public interface Interface4 { public void m1(); public void m2(); public void m3(); public void m4(); } public abstract class AbsAdapter implements Interface4{ //默认实现 @Override public void m1() { } @Override public void m2() { } @Override public void m3() { } @Override public void m4() { } } public class Client { public static void main(String[] args) { AbsAdapter absAdapter = new AbsAdapter() { //只需要去覆盖我们 需要使用 接口方法 @Override public void m1() { System.out.println(&quot;m1 method&quot;); } }; absAdapter.m1(); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"建造者模式","slug":"技术/建造者模式","date":"2020-10-08T03:30:00.000Z","updated":"2020-10-08T03:58:00.727Z","comments":true,"path":"2020/10/08/技术/建造者模式/","link":"","permalink":"/2020/10/08/技术/建造者模式/","excerpt":"","text":"基本介绍 建造者模式(BuilderPattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出 来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。 建造者模式的四个角色 Product(产品角色): 一个具体的产品对象。 Builder(抽象建造者): 创建一个 Product 对象的各个部件指定的 接口/抽象类。 ConcreteBuilder(具体建造者): 实现接口，构建和装配各个部件。 Director(指挥者): 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。 建造者模式解决盖房需求 需要建房子:这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程，下面我们 使用建造者模式(Builder Pattern)来完成 UML CODE public abstract class HouseBuilder { protected House house = new House(); //建造的流程流程写好 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); //建造好房子，将产品返回 public House buildHouse() { return house; } } public class CommonHouseBuilder extends HouseBuilder { @Override public void buildBasic() { System.out.println(&quot;普通房子打地基5米&quot;); } @Override public void buildWalls() { System.out.println(&quot;普通房子砌墙10厘米&quot;); } @Override public void roofed() { System.out.println(&quot;普通房子屋顶&quot;); } } public class HighHouseBuilder extends HouseBuilder { @Override public void buildBasic() { System.out.println(&quot; 高楼的打地基100米 &quot;); } @Override public void buildWalls() { System.out.println(&quot; 高楼的砌墙20厘米 &quot;); } @Override public void roofed() { System.out.println(&quot; 高楼的透明屋顶 &quot;); } } public class HouseDirector { HouseBuilder houseBuilder; public HouseDirector(HouseBuilder houseBuilder) { this.houseBuilder = houseBuilder; } //如何处理建造房子的流程，交给指挥者 public House constructHouse() { houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); } } public class House { public String base; public String wall; public String rooted; } public class Client { public static void main(String[] args) { HouseDirector houseDirector = new HouseDirector(new CommonHouseBuilder()); //完成盖房子，返回产品(普通房子) House house = houseDirector.constructHouse(); } } 优点 产品和产品建造过程解耦，便于扩展和维护","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"原型模式","slug":"技术/原型模式","date":"2020-10-07T14:28:00.000Z","updated":"2020-10-07T15:14:41.085Z","comments":true,"path":"2020/10/07/技术/原型模式/","link":"","permalink":"/2020/10/07/技术/原型模式/","excerpt":"","text":"基本介绍 原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象 1.基本类型的拷贝CODE public class Sheep implements Cloneable{ public String name; public int age; public Sheep friend;//是对象, 克隆是会如何处理, 默认是浅拷贝 public Sheep(String name, int age) { this.name = name; this.age = age; } @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } public class Client { public static void main(String[] args) throws CloneNotSupportedException { Sheep sheep1 = new Sheep(&quot;zhangsan&quot;,1); Sheep sheep2 = new Sheep(&quot;lisi&quot;, 2); sheep1.friend = sheep2; sheep2.friend = sheep1; Sheep sheep3 = (Sheep)sheep1.clone(); System.out.println(sheep3 == sheep1);//false System.out.println(sheep3.friend == sheep1.friend);//true } } 注意 成员变量为对象时，克隆是浅拷贝，使用默认拷贝是拷贝的地址 2.深拷贝基本介绍 复制对象的所有基本数据类型的成员变量值 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝 深拷贝实现方式1:重写clone方法来实现深拷贝 深拷贝实现方式2:通过对象序列化实现深拷贝(推荐) CODE package blog.prototype; import java.io.Serializable; public class DeepCloneableTarget implements Serializable, Cloneable { public String cloneName; public String cloneClass; public DeepCloneableTarget(String cloneName, String cloneClass) { this.cloneName = cloneName; this.cloneClass = cloneClass; } //因为该类的属性，都是 String , 因此我们这里使用默认的 clone 完成即可 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } package blog.prototype; import java.io.*; public class DeepProtoType implements Serializable, Cloneable { public String name; public DeepCloneableTarget deepCloneableTarget; //深拷贝 - 方式 1 使用clone 方法 @Override protected Object clone() throws CloneNotSupportedException { Object deep = null; //这里完成对基本数据类型(属性)和 String 的克隆 deep = super.clone(); //对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType)deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone(); return deepProtoType; } //深拷贝 - 方式 2 通过对象的序列化实现 (推荐) public Object deepClone() { //创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; DeepProtoType copyObj = null; try { //序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); //当前这个对象以对象流的方式输出 //反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); copyObj = (DeepProtoType)ois.readObject(); } catch (Exception e) { e.printStackTrace(); } finally { try { bos.close(); oos.close(); bis.close(); ois.close(); } catch (IOException e) { e.printStackTrace(); } } return copyObj; } } package blog.prototype; public class Client { public static void main(String[] args) throws CloneNotSupportedException { DeepCloneableTarget deepCloneableTarget = new DeepCloneableTarget(&quot;cloneName&quot;,&quot;cloneClass&quot;); DeepProtoType deepProtoType = new DeepProtoType(); deepProtoType.name = &quot;DeepProtoType&quot;; deepProtoType.deepCloneableTarget = deepCloneableTarget; DeepProtoType deepProtoType1 = (DeepProtoType) deepProtoType.clone(); System.out.println(deepProtoType1.name); System.out.println(deepProtoType1.deepCloneableTarget.cloneName); System.out.println(deepProtoType.deepCloneableTarget == deepProtoType1.deepCloneableTarget);//false DeepProtoType deepProtoType2 = (DeepProtoType) deepProtoType.deepClone(); System.out.println(deepProtoType2.name); System.out.println(deepProtoType2.deepCloneableTarget.cloneName); System.out.println(deepProtoType.deepCloneableTarget == deepProtoType2.deepCloneableTarget);//false } } 优缺点 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率 不用重新初始化对象，而是动态地获得对象运行时的状态 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码 在实现深克隆的时候可能需要比较复杂的代码 缺点:需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则，这点请注意.","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"工厂模式","slug":"技术/工厂模式","date":"2020-10-07T06:00:00.000Z","updated":"2020-10-07T15:10:02.769Z","comments":true,"path":"2020/10/07/技术/工厂模式/","link":"","permalink":"/2020/10/07/技术/工厂模式/","excerpt":"","text":"1.简单工厂模式看一个披萨的项目:要便于披萨种类的扩展，要便于维护 披萨的种类很多(比如 GreekPizz、CheesePizz 等) 披萨的制作有 prepare，bake, cut, box 完成披萨店订购功能。 思路 把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类就可，其它有创建到 Pizza 对象的代码就不需要修改了 UML package blog.factory; import blog.factory.pizza.CheesePizza; import blog.factory.pizza.GreekPizza; import blog.factory.pizza.Pizza; public class SimpleFactory { //简单工厂模式 public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;奶酪&quot;)) { pizza = new CheesePizza(); pizza.setName(&quot;奶酪披萨&quot;); } else if (orderType.equals(&quot;希腊&quot;)) { pizza = new GreekPizza(); pizza.setName(&quot;希腊披萨&quot;); } return pizza; } //简单工厂模式，静态工厂模式 public static Pizza createPizza2(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;奶酪&quot;)) { pizza = new CheesePizza(); pizza.setName(&quot;奶酪披萨&quot;); } else if (orderType.equals(&quot;希腊&quot;)) { pizza = new GreekPizza(); pizza.setName(&quot;希腊披萨&quot;); } return pizza; } } package blog.factory; import blog.factory.pizza.Pizza; public class OrderPizza { private SimpleFactory simpleFactory; public OrderPizza(SimpleFactory simpleFactory) { this.simpleFactory = simpleFactory; } public void makePizza(String orderType) { Pizza pizza = simpleFactory.createPizza(orderType); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } package blog.factory; public class Test { public static void main(String[] args) { OrderPizza orderPizza = new OrderPizza(new SimpleFactory()); orderPizza.makePizza(&quot;希腊&quot;); } } package blog.factory.pizza; public abstract class Pizza { private String name; //不同类型制作材料的准备不同 public abstract void prepare(); public void bake() { System.out.println(name + &quot;baking&quot;); } public void cut() { System.out.println(name + &quot;cutting&quot;); } public void box() { System.out.println(name + &quot;boxing&quot;); } public String getName() { return name; } public void setName(String name) { this.name = name; } } package blog.factory.pizza; public class GreekPizza extends Pizza { @Override public void prepare() { System.out.println(&quot;给希腊披萨准备原材料&quot;); } } package blog.factory.pizza; public class CheesePizza extends Pizza{ @Override public void prepare() { System.out.println(&quot;制作奶酪披萨，准备材料&quot;); } } 2.工厂方法模式需求 披萨项目新的需求:客户在点披萨时，可以点不同口味的披萨，比如 北京的奶酪 pizza、北京的希腊 pizza 或 者是伦敦的奶酪 pizza、伦敦的希腊 pizza。 思路 使用简单工厂模式，创建不同的简单工厂类，比如 BJPizzaSimpleFactory、LDPizzaSimpleFactory 等等.从当前这个案例来说，也是可以的，但是考虑到项目的规模，以及软件的可维护性、可扩展性并不是特别好 工厂方法模式设计方案:将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。 工厂方法模式:定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例 化推迟到子类。UML CODE public abstract class PizzaFactory { public abstract Pizza createPizza(String orderType); } public class BJPizzaFactory extends PizzaFactory{ @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new BJGreekPizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new BJGreekPizza(); } return pizza; } } public class LDPizzaFactory extends PizzaFactory{ @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new LDCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new LDGreekOPizza(); } return pizza; } } public class Order { private PizzaFactory pizzaFactory; public Order(PizzaFactory pizzaFactory) { this.pizzaFactory = pizzaFactory; } public void makePizza(String type) { Pizza pizza = pizzaFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } public class Client { public static void main(String[] args) { Order order = new Order(new LDPizzaFactory()); order.makePizza(&quot;greek&quot;); } } 3.抽象工厂模式思路 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类，完成了对地点BJ和LD的区分 UML CODE public interface AbsFactory { public Pizza createPizza(String orderType); } public class BJFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new BJCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new BJGreekPizza(); } return pizza; } } public class LDFactory implements AbsFactory { @Override public Pizza createPizza(String orderType) { Pizza pizza = null; if (orderType.equals(&quot;cheese&quot;)) { pizza = new LDCheesePizza(); } else if (orderType.equals(&quot;greek&quot;)) { pizza = new LDGreekOPizza(); } return pizza; } } public class Order { private AbsFactory absFactory; public Order(AbsFactory absFactory) { this.absFactory = absFactory; } public void makePizza(String type) { Pizza pizza = absFactory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); } } public class Client { public static void main(String[] args) { Order order = new Order(new LDFactory()); order.makePizza(&quot;cheese&quot;); } }","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"单例模式","slug":"技术/单例模式","date":"2020-10-06T14:28:00.000Z","updated":"2020-10-06T14:30:45.475Z","comments":true,"path":"2020/10/06/技术/单例模式/","link":"","permalink":"/2020/10/06/技术/单例模式/","excerpt":"","text":"1.饿汉式(静态常量)package blog.singleton; public class SingletonTest { public static void main(String[] args) { Singleton singleton1 = Singleton.getInstance(); Singleton singleton2 = Singleton.getInstance(); System.out.println(singleton1 == singleton2); } } class Singleton { // 1.构造器私有化，防止外部new private Singleton() {} // 2.在装载时，完成实例化 private final static Singleton instance = new Singleton(); // 3.通过公有静态方法，返回实例对象 public static Singleton getInstance() { return instance; } } 优点 类装载的时候就完成实例化。避免了线程同步问题。 缺点 在类装载的时候就完成实例化，没有达到LazyLoading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大 多数都是调用 getInstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式(或者其他的静 态方法)导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果 结论 这种单例模式可用，可能造成内存浪费 2.饿汉式(静态代码块)class Singleton { private Singleton() {} private static Singleton instance; { instance = new Singleton(); } public static Singleton getInstance() { return instance; } } 优点缺点这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执 行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 结论这种单例模式可用，但是可能造成内存浪费 3.懒汉式(线程不安全)class Singleton { private static Singleton instance; private Singleton(){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 优缺点 起到了LazyLoading的效果，但是只能在单线程下使用。 如果在多线程下，一个线程进入了if(singleton==null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式 结论 实际开发中，不要使用这种方式. 4.懒汉式(线程安全，同步方法，不推荐使用)class Singleton { private static Singleton instance; private Singleton(){}; //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 优缺点 解决了线程安全问题 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低 结论 实际开发中，不推荐使用这种方式 5. 懒汉式(线程安全，同步代码块，不推荐)class Singleton { private static Singleton instance; private Singleton(){}; public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { instance = new Singleton(); } } return instance; } } 优缺点 与上一个模式同样，解决了线程安全问题，但效率太低了 6.双重检查(推荐使用)class Singleton { private static volatile Singleton instance;//volatile 很重要 private Singleton() {} //加入双重检查代码，解决线程安全问题, 同时解决懒加载问题,同时保证了效率, 推荐使用 public static synchronized Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 优缺点 Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (singleton == null)检查，这 样就可以保证线程安全了。 这样，实例化代码只用执行一次，后面再次访问时，判断if(singleton==null)，直接return实例化对象，也避 免的反复进行方法同步. 线程安全;延迟加载;效率较高 volatile 禁止指令重排 结论 在实际开发中，推荐使用这种单例设计模式 7.静态内部类(推荐)class Singleton { private static volatile Singleton instance;//volatile 很重要 private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static synchronized Singleton getInstance() { return SingletonInstance.INSTANCE; } } 优缺点 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 结论 推荐使用 8.枚举（推荐使用）package blog.singleton; public class SingletonTest { public static void main(String[] args) { Singleton singleton1 = Singleton.INSTANCE; Singleton singleton2 = Singleton.INSTANCE; System.out.println(singleton1 == singleton2); singleton1.sayOk(); } } // enum Singleton { INSTANCE;//枚举实例 public void sayOk() { System.out.println(&quot;ok~&quot;); } } 优缺点 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建 新的对象。 这种方式是EffectiveJava作者JoshBloch提倡的方式 结论 推荐使用 9.使用场景需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即:重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session 工厂等)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"/tags/设计模式/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}